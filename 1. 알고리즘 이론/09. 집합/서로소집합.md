#  서로소 집합
- 공통 원소가 없는 두 집합

## 예시 
{1,2} 와 {3,4}는 서로소.
{1,2} 와 {2,3}는 서로소가 아님.

# 서로소 집합 자료구조(union-find 자료구조)
- 서로소 부분 집합들로 나누어진 원소들의 데이터를 처리하기 위한 자료구조
- union과 find 2개의 연산으로 조작할 수 있다.

= union (합집합) : 2개의 원소가 포함된 집합을 하나의 집합으로 합치는 연산
- find (찾기) : 특정한 원소가 속한 집합이 어떤 집합인지 알려주는 연산

**스택과 큐가 push/pop으로 이루어진 것처럼, 서로소 집합은 합집합과 찾기 연산으로 구성된다.**
- 보통 트리로 표현하는데, 합집합 연산이 주어졌을 때 트리 자료구조로 집합을 표현하는 서로소 집합 계산
    1. union (합집합) 연산을 확인하여, 서로 연결된 두 노드 확인
      - A, B의 루트노드 A' ,B' 를 각각 찾는다.
      - A' B' 의 부모노드로 설정한다. ㅣ (B' 가 A'을 가리키도록 한다.)
    2. 모든 union(합집합) 연산을 처리할 때까지 1번 연산을 반복.
    3. 트리 구조상 번호가 작은 노드가 부모노드가 될 수 밖에 없다.

# 단계 상세
1. 가장 먼저 노드의 개수(V) 크기의 부모 테이블 초기화.  (자기자신 - 자기자신으로 / 1-1  2-2  3-3  4-4  5-5 ... )
    - **(이 때 중요한 것은, 부모테이블은 말그대로 부모의 정보만을 가짐.)**
    - 우리가 실제로 루트를 확인하고자 할때는 재귀적으로 부모를 거슬러 올라가서 최종적인 루트 노드를 찾아야 한다.


2. 첫 번째 union 연산을 확인하면 1,4를 합친다.
    - 1,4의 부모노드 확인(1,4)
    - 1 = 1의 부모, 4의 부모 중 작은 값
    - 4 = 1의 부모, 4의 부모 중 작은 값

3. 두 번째 union 연산을 확인하면 2,3.
    - 2,3 의 부모노드 확인 (2,3)
    - 2 = 2의 부모, 3의 부모 중 작은 값
    - 3 = 2의 부모, 3의 부모 중 작은 값

4. 세 번째 union 연산을 확인하면 2,4
    - 2,4의 부모노드 확인 ( 2, 1 )
    - 2 = 2의 부모, 1의 부모 중 작은 값
    - 4 = 2의 부모, 1의 부모 중 작은 값

5. 네 번째 union 연산을 확인하면 5, 6
    - 5,6의 부모노드 확인 ( 5, 6 )
    - 5 = 5의 부모, 6의 부모 중 작은 값
    - 6 = 5의 부모, 6의 부모 중 작은 값

6. 모든 union 연산을 해결했다면, 부모 테이블을 보고 최종 노드까지 거슬러 올라가야함.
    - 부모노드가 없을 때(부모노드와 본인이 같을 때)까지 거슬러 올라간다.


## 경로 압축기법
- 1 <- 2 <- 3 <- 4 <- 5 순서대로 부모 노드를 따라 간다고 쳤을때, 애초에 다 부모노드가 1에 수렴하기 때문에 재귀적으로 find를 호출해서 부모테이블을 갱신시키는 방법.
  
  ```java
  int find_parent(int[] parent, int x){
    if (parent[x] != x){
        parent[x] = find_parent(parent,parent[x]);
    }
    return parent[x];s
  }
  ```
  